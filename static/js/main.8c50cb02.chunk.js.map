{"version":3,"sources":["components/PassageTokens.tsx","data/words.ts","data/verses.ts","parsing/transition.ts","parsing/input.ts","parsing/errors.ts","data/books.ts","data/conversion.ts","functions/invertObject.ts","parsing/outputs.ts","parsing/state.ts","parsing/parse.ts","passage/passage.ts","App.tsx","index.tsx"],"names":["PassageTokens","props","passage","tokens","leftover","className","map","token","index","key","type","string","wordGroups","english_10","british_10","english_20","british_20","english_35","british_35","english_40","british_40","english_50","british_50","english_55","british_55","english_60","british_60","english_70","british_70","randomElement","array","Math","floor","random","length","randomWord","oddity","clamped","max","min","slice","bookWithTotal","cumulative","total","reduce","acc","val","Object","assign","totalUp","testament","totalled","book","withTotal","otVerseCounts","otVerseCountsPure","ntVerseCounts","ntVerseCountsPure","verseCounts","o","n","transitionMatrix","initial","number","chapter","colon","hyphen","verse","chapterHyphen","bookEnd","chapterEnd","verseEnd","error","end","nextStateType","stateType","inputType","Input","value","ParseError","message","name","Error","BoundsError","BadInputError","inputValueError","state","input","next","inputMinValue","inputMaxValue","boundType","endsWith","inRef","reference","otBooks","ntBooks","books","bookAbbrvs","turkishLetterNumbers","ç","ş","ö","ü","Ç","Ş","Ö","Ü","reverse","object","ret","keys","forEach","String","invertObject","toMnemonic","section","fromCodePoint","toString","bookSection","toLowerCase","addColon","a","b","test","from","to","valueStates","State","inputs","this","errorCheckInput","newStateType","newState","indexOf","valueState","sectionTo","toReference","doingEnd","includes","transition","initialState","parseBookName","matches","startsWith","nameIndex","findIndex","abbrvIndex","nameFound","whitespaceRegex","parseInput","ntBookInput","otBookInput","singleLetterNumber","codepoint","codePointAt","match","toNumber","numberInput","availableDigits","Number","parseMultiDigitNumber","whitespaceMatch","Book","Token","addUp","Passage","remainingString","stateFromString","fromValues","mnemonic","bookObj","undefined","count","chapterCount","nthVerse","parse","randomWordPassage","word","console","log","App","useState","setInput","setOddity","showSlider","setShowSlider","refEntered","linkRef","useRef","useMemo","filters","maxWords","filteredWords","group","groupOddity","push","sort","filterWords","showMnemonics","onClick","onKeyPress","e","current","click","onChange","target","ref","rel","href","replace","role","aria-label","style","margin","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"43HAIaA,G,MAAgB,SAACC,GAAiC,IAAD,EAC/BA,EAAMC,QAA3BC,EADoD,EACpDA,OAAQC,EAD4C,EAC5CA,SAChB,OACE,0BAAMC,UAAU,iBACbF,EAAOG,KAAI,SAACC,EAAOC,GAAR,OACV,0BAAMC,IAAKD,EAAOH,UAAWE,EAAMG,KAAO,SACvCH,EAAMI,WAGVP,K,uICIDQ,EAAa,CAAC,GAAD,mBACbC,GADa,YACEC,IADF,sBAEbC,GAFa,YAEEC,IAFF,sBAGbC,GAHa,YAGEC,IAHF,sBAIbC,GAJa,YAIEC,IAJF,sBAKbC,GALa,YAKEC,IALF,sBAMbC,GANa,YAMEC,IANF,sBAObC,GAPa,YAOEC,IAPF,sBAQbC,GARa,YAQEC,KAGrB,SAASC,EAAiBC,GACxB,OAAOA,EAAMC,KAAKC,MAAMD,KAAKE,SAAWH,EAAMI,SAGzC,SAASC,IAAgC,IAArBC,EAAoB,uDAAX,EAC5BC,EAAUN,KAAKO,IAAI,EAAGP,KAAKQ,IAAI,EAAGH,IACxC,OAAOP,EAAcA,EAAcjB,EAAW4B,MAAM,EAAGH,EAAU,K,yDCvBnE,SAASI,EAAcX,EAAaY,GAClC,IAAMC,EAAQb,EAAMc,QAAO,SAACC,EAAKC,GAAN,OAAcD,EAAMC,KAC/C,OAAOC,OAAOC,OAAOlB,EAAO,CAAEa,QAAOD,WAAYA,EAAaC,IAGhE,IAAMM,EAAU,SACdC,GAE0C,IAD1CR,EACyC,uDAD5B,EAEPS,EAAWD,EAAU5C,KAAI,SAAC8C,GAC9B,IAAMC,EAAYZ,EAAcW,EAAMV,GAEtC,OADAA,GAAcW,EAAUV,MACjBU,KAEHV,EAAQQ,EAASP,QAAO,SAACC,EAAKO,GAAN,OAAeP,EAAMO,EAAKT,QAAO,GAC/D,OAAOI,OAAOC,OAAOG,EAAU,CAAER,QAAOD,gBAG7BY,EAAsDL,EACjEM,GAEWC,EAAsDP,EACjEQ,EACAH,EAAcX,OAGHe,EAAc,CACzBC,EAAGL,EACHM,EAAGJ,EACHb,MAAOW,EAAcX,MAAQa,EAAcb,MAC3CD,WAAYc,EAAcd,YCdtBmB,EAAqC,CACzCC,QAAS,CACPC,OAAQ,QAEVX,KAAM,CACJW,OAAQ,WAEVC,QAAS,CACPD,OAAQ,QACRE,MAAO,UACPC,OAAQ,iBAEVC,MAAO,CACLD,OAAQ,cAEVE,cAAe,CACbL,OAAQ,cAEVM,QAAS,GACTC,WAAY,CACVP,OAAQ,WACRE,MAAO,cAETM,SAAU,GACVC,MAAO,GACPC,IAAK,IAGA,SAASC,EACdC,EACAC,GAEA,MAAqB,QAAdA,EACH,MACAf,EAAiBc,GAAWC,KACX,eAAdA,EAA6BD,EAAY,SC3D3C,IAAME,EACX,WACWnE,EACAC,EACAmE,GAGR,IAFQ5B,EAET,uDAFuC,KAC9BsB,EACT,uDADoC,KACpC,yBALS9D,OAKT,KAJSC,SAIT,KAHSmE,QAGT,KAFS5B,YAET,KADSsB,SCJSO,EAAtB,kDACE,WAAYC,GAAkB,IAAD,8BAC3B,cAAMA,IACDC,KAAO,aAFe,EAD/B,sBAAyCC,QAM5BC,EAAb,kDACE,WAAYH,GAAkB,IAAD,8BAC3B,cAAMA,IACDC,KAAO,cAFe,EAD/B,UAAiCF,GAMpBK,EAAb,kDACE,WAAYJ,GAAkB,IAAD,8BAC3B,cAAMA,IACDC,KAAO,gBAFe,EAD/B,UAAmCF,GAiCnC,SAASM,EAAgBC,EAAcC,GACrC,IAAMhD,EAZR,SAAuB+C,EAAcC,GAAuB,IAAD,MACnDC,EAAOd,EAAcY,EAAM5E,KAAM,UACjC0C,GAAO,UAAAkC,EAAMlC,YAAN,eAAY0B,SAAU,EAC7Bd,GAAU,UAAAsB,EAAMtB,eAAN,eAAec,SAAU,EACnCX,GAAQ,UAAAmB,EAAMnB,aAAN,eAAaW,SAAU,EACrC,MAAa,YAATU,EAA2BpC,EAAO,EACzB,eAAToC,EAA8BxB,EAAU,EAC/B,aAATwB,EAA4BrB,EAAQ,EACjC,EAIKsB,CAAcH,GACpBhD,EA5BR,SAAuBgD,EAAcC,GAAuB,IAAD,IACnDnC,GAAO,UAACkC,EAAMjB,SAAWiB,EAAMlC,YAAxB,eAA+B0B,QAAS,EAC/Cd,GAAU,UAACsB,EAAMhB,YAAcgB,EAAMtB,eAA3B,eAAqCc,QAAS,EACxDpB,EACqC,OAAxC4B,EAAMpC,WAAaqC,EAAMrC,WACtBI,EACAE,EACAgC,EAAOd,EAAcY,EAAM5E,KAAM,UACvC,MAAa,SAAT8E,GAA4B,YAATA,EAA2B9B,EAAYxB,OACjD,YAATsD,GAA+B,eAATA,EACjB9B,EAAYN,EAAO,GAAGlB,OAClB,UAATsD,GAA6B,aAATA,EACf9B,EAAYN,EAAO,GAAGY,EAAU,GAClC,EAeK0B,CAAcJ,EAAOC,GAC3BT,EAAQS,EAAMT,OAAS,EACvBU,EAAOd,EAAcY,EAAM5E,KAAM,UACjCiF,EAAYH,EAAKI,SAAS,OAASJ,EAAKhD,MAAM,GAAI,GAAKgD,EAE7D,GAAIlD,EAAMC,EAAK,OAAO,IAAI4C,EAAJ,mBAA4BQ,IAClD,GAAIb,EAAQvC,EACV,OAAO,IAAI4C,EAAJ,UAAmBQ,EAAnB,yBAA6CpD,EAAM,IAC5D,GAAIuC,EAAQxC,EAAK,CACf,IAAMuD,EAAQP,EAAMQ,UAAY,MAAQR,EAAMQ,UAAY,GAC1D,OAAO,IAAIX,EAAJ,UACFL,EADE,+BAC0BxC,EAD1B,YACiCqD,EADjC,aAC+CE,IAGxD,OAAO,K,YClEIE,EAAU,CACrB,UACA,SACA,YACA,UACA,cACA,SACA,SACA,OACA,WACA,WACA,UACA,UACA,eACA,eACA,OACA,WACA,SACA,MACA,QACA,WACA,eACA,gBACA,SACA,WACA,eACA,UACA,SACA,QACA,OACA,OACA,UACA,QACA,QACA,QACA,WACA,YACA,SACA,YACA,WAGWC,EAAU,CACrB,UACA,OACA,OACA,OACA,OACA,SACA,gBACA,gBACA,YACA,YACA,cACA,aACA,kBACA,kBACA,YACA,YACA,QACA,WACA,UACA,QACA,UACA,UACA,SACA,SACA,SACA,OACA,cA0EWC,EAAQ,CACnBtC,EAAGoC,EACHnC,EAAGoC,GAEQE,EAAa,CACxBvC,EA5E0B,CAC1B,MACA,MACA,MACA,MACA,MACA,MACA,MACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,KACA,MACA,MACA,KACA,KACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,KACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,MACA,OAsCAC,EAnC0B,CAC1B,MACA,KACA,KA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","file":"static/js/main.8c50cb02.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./PassageTokens.css\";\nimport { Passage } from \"../passage/passage\";\n\nexport const PassageTokens = (props: { passage: Passage }) => {\n  const { tokens, leftover } = props.passage;\n  return (\n    <span className=\"parsedPassage\">\n      {tokens.map((token, index) => (\n        <span key={index} className={token.type + \"Token\"}>\n          {token.string}\n        </span>\n      ))}\n      {leftover}\n    </span>\n  );\n};\n","import english_10 from \"wordlist-english/english-words-10.json\";\nimport english_20 from \"wordlist-english/english-words-20.json\";\nimport english_35 from \"wordlist-english/english-words-35.json\";\nimport english_40 from \"wordlist-english/english-words-40.json\";\nimport english_50 from \"wordlist-english/english-words-50.json\";\nimport english_55 from \"wordlist-english/english-words-55.json\";\nimport english_60 from \"wordlist-english/english-words-60.json\";\nimport english_70 from \"wordlist-english/english-words-70.json\";\nimport british_10 from \"wordlist-english/british-words-10.json\";\nimport british_20 from \"wordlist-english/british-words-20.json\";\nimport british_35 from \"wordlist-english/british-words-35.json\";\nimport british_40 from \"wordlist-english/british-words-40.json\";\nimport british_50 from \"wordlist-english/british-words-50.json\";\nimport british_55 from \"wordlist-english/british-words-55.json\";\nimport british_60 from \"wordlist-english/british-words-60.json\";\nimport british_70 from \"wordlist-english/british-words-70.json\";\n\nconst wordGroups = [\n  [...english_10, ...british_10],\n  [...english_20, ...british_20],\n  [...english_35, ...british_35],\n  [...english_40, ...british_40],\n  [...english_50, ...british_50],\n  [...english_55, ...british_55],\n  [...english_60, ...british_60],\n  [...english_70, ...british_70],\n];\n\nfunction randomElement<T>(array: T[]): T {\n  return array[Math.floor(Math.random() * array.length)];\n}\n\nexport function randomWord(oddity = 0): string {\n  const clamped = Math.max(0, Math.min(7, oddity));\n  return randomElement(randomElement(wordGroups.slice(0, clamped + 1)));\n}\n\ninterface Filters {\n  oddity?: number;\n  startsWith?: string;\n  maxWords?: number;\n}\nexport function filterWords(filters: Filters = {}): string[] {\n  const { oddity = 0, startsWith, maxWords = 1000 } = filters;\n  const filteredWords: string[] = [];\n  wordGroups.forEach(\n    (group, groupOddity) =>\n      groupOddity <= oddity &&\n      group.forEach(\n        (word) =>\n          filteredWords.length < maxWords &&\n          (startsWith ? word.startsWith(startsWith) : true) &&\n          filteredWords.push(word)\n      )\n  );\n  return filteredWords.sort();\n}\n","import otVerseCountsPure from \"./otVerseCounts.json\";\nimport ntVerseCountsPure from \"./ntVerseCounts.json\";\n\ntype TotalledArray<T> = T[] & {\n  total: number;\n  cumulative: number;\n};\n\ntype Book = number[];\ntype Testament = Book[];\n\nfunction bookWithTotal(array: Book, cumulative: number): TotalledArray<number> {\n  const total = array.reduce((acc, val) => acc + val);\n  return Object.assign(array, { total, cumulative: cumulative + total });\n}\n\nconst totalUp = (\n  testament: Testament,\n  cumulative = 0\n): TotalledArray<TotalledArray<number>> => {\n  const totalled = testament.map((book) => {\n    const withTotal = bookWithTotal(book, cumulative);\n    cumulative += withTotal.total;\n    return withTotal;\n  });\n  const total = totalled.reduce((acc, book) => acc + book.total, 0);\n  return Object.assign(totalled, { total, cumulative });\n};\n\nexport const otVerseCounts: TotalledArray<TotalledArray<number>> = totalUp(\n  otVerseCountsPure as number[][]\n);\nexport const ntVerseCounts: TotalledArray<TotalledArray<number>> = totalUp(\n  ntVerseCountsPure as number[][],\n  otVerseCounts.total\n);\n\nexport const verseCounts = {\n  o: otVerseCounts,\n  n: ntVerseCounts,\n  total: otVerseCounts.total + ntVerseCounts.total,\n  cumulative: ntVerseCounts.cumulative,\n};\n","export type StateType =\n  | \"initial\"\n  | \"book\"\n  | \"chapter\"\n  | \"verse\"\n  | \"chapterHyphen\"\n  | \"bookEnd\"\n  | \"chapterEnd\"\n  | \"verseEnd\"\n  | \"error\"\n  | \"end\";\n\nexport type InputType =\n  | \"number\"\n  | \"hyphen\"\n  | \"whitespace\"\n  | \"end\"\n  | \"error\"\n  | \"colon\";\n\ntype StateTransition = {\n  readonly [E in InputType]?: StateType;\n};\ntype TransitionMatrix = {\n  readonly [E in StateType]: StateTransition;\n};\n\nconst transitionMatrix: TransitionMatrix = {\n  initial: {\n    number: \"book\",\n  },\n  book: {\n    number: \"chapter\",\n  },\n  chapter: {\n    number: \"verse\",\n    colon: \"chapter\",\n    hyphen: \"chapterHyphen\",\n  },\n  verse: {\n    hyphen: \"chapterEnd\", // or ChapterHyphen! Change to array when upgrading to have paths\n  },\n  chapterHyphen: {\n    number: \"chapterEnd\",\n  },\n  bookEnd: {},\n  chapterEnd: {\n    number: \"verseEnd\",\n    colon: \"chapterEnd\",\n  },\n  verseEnd: {},\n  error: {},\n  end: {},\n};\n\nexport function nextStateType(\n  stateType: StateType,\n  inputType: InputType\n): StateType {\n  return inputType === \"end\"\n    ? \"end\"\n    : transitionMatrix[stateType][inputType] ||\n        (inputType === \"whitespace\" ? stateType : \"error\");\n}\n","import { InputType } from \"./transition\";\nimport { ParseError } from \"./errors\";\n\nexport class Input {\n  constructor(\n    readonly type: InputType,\n    readonly string: string,\n    readonly value: number | null,\n    readonly testament: \"o\" | \"n\" | null = null,\n    readonly error: ParseError | null = null\n  ) {}\n}\n","import { State } from \"./state\";\nimport { ntVerseCounts, otVerseCounts } from \"../data/verses\";\nimport { nextStateType } from \"./transition\";\nimport { Input } from \"./input\";\n\nexport abstract class ParseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ParseError\";\n  }\n}\nexport class BoundsError extends ParseError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"BoundsError\";\n  }\n}\nexport class BadInputError extends ParseError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"BadInputError\";\n  }\n}\n\nfunction inputMaxValue(state: State, input: Input): number {\n  const book = (state.bookEnd || state.book)?.value || 1;\n  const chapter = (state.chapterEnd || state.chapter)?.value || 1;\n  const verseCounts =\n    (state.testament || input.testament) === \"o\"\n      ? otVerseCounts\n      : ntVerseCounts;\n  const next = nextStateType(state.type, \"number\");\n  if (next === \"book\" || next === \"bookEnd\") return verseCounts.length;\n  if (next === \"chapter\" || next === \"chapterEnd\")\n    return verseCounts[book - 1].length;\n  if (next === \"verse\" || next === \"verseEnd\")\n    return verseCounts[book - 1][chapter - 1];\n  return 0;\n}\nfunction inputMinValue(state: State, input: Input): number {\n  const next = nextStateType(state.type, \"number\");\n  const book = state.book?.value || -1;\n  const chapter = state.chapter?.value || -1;\n  const verse = state.verse?.value || -1;\n  if (next === \"bookEnd\") return book + 1;\n  if (next === \"chapterEnd\") return chapter + 1;\n  if (next === \"verseEnd\") return verse + 1;\n  return 0;\n}\n\nfunction inputValueError(state: State, input: Input): Error | null {\n  const min = inputMinValue(state, input);\n  const max = inputMaxValue(state, input);\n  const value = input.value || 0;\n  const next = nextStateType(state.type, \"number\");\n  const boundType = next.endsWith(\"End\") ? next.slice(0, -3) : next;\n\n  if (max < min) return new BoundsError(`No valid ${boundType}`);\n  if (value < min)\n    return new BoundsError(`${boundType} must be over ${min - 1}`);\n  if (value > max) {\n    const inRef = state.reference ? \"in \" + state.reference : \"\";\n    return new BoundsError(\n      `${value} is over maximum of ${max} ${boundType}s ${inRef}`\n    );\n  }\n  return null;\n}\n\nexport function errorCheckInput(state: State, input: Input): Input {\n  const { type, string, value, testament } = input;\n  if (type !== \"number\") return input;\n  const error = inputValueError(state, input);\n  if (!error) return input;\n  return new Input(\"error\", string, value, testament, error);\n}\n","export const otBooks = [\n  \"Genesis\",\n  \"Exodus\",\n  \"Leviticus\",\n  \"Numbers\",\n  \"Deuteronomy\",\n  \"Joshua\",\n  \"Judges\",\n  \"Ruth\",\n  \"1 Samuel\",\n  \"2 Samuel\",\n  \"1 Kings\",\n  \"2 Kings\",\n  \"1 Chronicles\",\n  \"2 Chronicles\",\n  \"Ezra\",\n  \"Nehemiah\",\n  \"Esther\",\n  \"Job\",\n  \"Psalm\",\n  \"Proverbs\",\n  \"Ecclesiastes\",\n  \"Song of Songs\",\n  \"Isaiah\",\n  \"Jeremiah\",\n  \"Lamentations\",\n  \"Ezekiel\",\n  \"Daniel\",\n  \"Hosea\",\n  \"Joel\",\n  \"Amos\",\n  \"Obadiah\",\n  \"Jonah\",\n  \"Micah\",\n  \"Nahum\",\n  \"Habakkuk\",\n  \"Zephaniah\",\n  \"Haggai\",\n  \"Zechariah\",\n  \"Malachi\",\n];\n\nexport const ntBooks = [\n  \"Matthew\",\n  \"Mark\",\n  \"Luke\",\n  \"John\",\n  \"Acts\",\n  \"Romans\",\n  \"1 Corinthians\",\n  \"2 Corinthians\",\n  \"Galatians\",\n  \"Ephesians\",\n  \"Philippians\",\n  \"Colossians\",\n  \"1 Thessalonians\",\n  \"2 Thessalonians\",\n  \"1 Timothy\",\n  \"2 Timothy\",\n  \"Titus\",\n  \"Philemon\",\n  \"Hebrews\",\n  \"James\",\n  \"1 Peter\",\n  \"2 Peter\",\n  \"1 John\",\n  \"2 John\",\n  \"3 John\",\n  \"Jude\",\n  \"Revelation\",\n];\n\nexport const otBookAbbrvs = [\n  \"Gen\",\n  \"Exo\",\n  \"Lev\",\n  \"Num\",\n  \"Deu\",\n  \"Jos\",\n  \"Jud\",\n  \"Ru\",\n  \"1S\",\n  \"2S\",\n  \"1K\",\n  \"2K\",\n  \"1C\",\n  \"2C\",\n  \"Ezr\",\n  \"Ne\",\n  \"Est\",\n  \"Job\",\n  \"Ps\",\n  \"Pr\",\n  \"Ecc\",\n  \"Son\",\n  \"Is\",\n  \"Jer\",\n  \"Lam\",\n  \"Eze\",\n  \"Dan\",\n  \"Ho\",\n  \"Joe\",\n  \"Amo\",\n  \"Oba\",\n  \"Jon\",\n  \"Mic\",\n  \"Nah\",\n  \"Hab\",\n  \"Zep\",\n  \"Hag\",\n  \"Zec\",\n  \"Mal\",\n];\n\nexport const ntBookAbbrvs = [\n  \"Mat\",\n  \"Mk\",\n  \"Lk\",\n  \"Jn\",\n  \"Acts\",\n  \"Rom\",\n  \"1Cor\",\n  \"2Cor\",\n  \"Gala\",\n  \"Ephe\",\n  \"Colo\",\n  \"Phi\",\n  \"1Th\",\n  \"2Th\",\n  \"1Ti\",\n  \"2Ti\",\n  \"Ti\",\n  \"Phm\",\n  \"Heb\",\n  \"Js\",\n  \"1P\",\n  \"2P\",\n  \"1J\",\n  \"2J\",\n  \"3J\",\n  \"Jude\",\n  \"Rev\",\n];\nexport const books = {\n  o: otBooks,\n  n: ntBooks,\n};\nexport const bookAbbrvs = {\n  o: otBookAbbrvs,\n  n: ntBookAbbrvs,\n};\n","import { invertObject } from \"../functions/invertObject\";\n\nconst turkishLetterNumbers = {\n  ç: 27,\n  ş: 28,\n  ö: 29,\n  ü: 30,\n  Ç: 57,\n  Ş: 58,\n  Ö: 59,\n  Ü: 60,\n} as const;\n\nconst reverse = invertObject(turkishLetterNumbers);\n\nexport const toNumber = (input: string): number | null => {\n  const codepoint = input.codePointAt(0);\n  if (!codepoint) return null;\n  if (input.match(/^[a-z]/)) return codepoint - 96;\n  if (input.match(/^[A-Z]/)) return codepoint - 34;\n  if (input.match(/^0/)) return 30;\n  if (input.match(/^[çÇşŞöÖüÜ]/))\n    return turkishLetterNumbers[input[0] as keyof typeof turkishLetterNumbers];\n  return null;\n};\n\nexport const toString = (input: number): string | null => {\n  if (reverse[input]) return reverse[input];\n  if (input >= 1 && input <= 26) return String.fromCodePoint(input + 96);\n  if (input >= 31 && input <= 56) return String.fromCodePoint(input + 34);\n  return null;\n};\n","export function invertObject<O extends { [index: string]: number | string }>(\n  object: O\n): {\n  [index: string]: string;\n} {\n  const ret: { [index: string]: string } = {};\n  Object.keys(object).forEach((key) => {\n    ret[object[String(key)]] = key;\n  });\n  return ret;\n}\n","import { bookAbbrvs, ntBooks, otBooks } from \"../data/books\";\nimport { toString } from \"../data/conversion\";\nimport { Input } from \"./input\";\nimport { State } from \"./state\";\n\nexport function toReference(state: State) {\n  const {\n    testament,\n    book,\n    chapter,\n    verse,\n    bookEnd,\n    chapterEnd,\n    verseEnd,\n  } = state;\n  const books = testament === \"o\" ? otBooks : ntBooks;\n  const sectionTo =\n    (bookEnd ? books[(bookEnd.value || 1) - 1] + \" \" : \"\") +\n    (chapterEnd?.value || \"\") +\n    (chapterEnd && verseEnd ? \":\" : \"\") +\n    (verseEnd?.value || \"\");\n  return (\n    (book ? books[(book.value || 1) - 1] : \"\") +\n    (chapter ? \" \" + chapter.value : \"\") +\n    (verse ? \":\" + verse.value : \"\") +\n    (sectionTo ? \"-\" + sectionTo : \"\")\n  );\n}\n\nexport function toMnemonic(state: State): string {\n  const {\n    testament,\n    book,\n    chapter,\n    verse,\n    bookEnd,\n    chapterEnd,\n    verseEnd,\n  } = state;\n  const section = (input: Input | null): string =>\n    (input?.value && toString(input?.value)) || input?.value?.toString() || \"\";\n  const otBook = (input: Input | null): string =>\n    ((input?.value && bookAbbrvs[\"o\"][input?.value - 1]) || \"\").toLowerCase();\n  const bookSection = testament === \"n\" ? section : otBook;\n  const addColon = (a: string, b: string) =>\n    /\\d+/.test(a) && /\\d+/.test(b) ? a + \":\" + b : a + b;\n  const from = bookSection(book) + addColon(section(chapter), section(verse));\n  const to =\n    bookSection(bookEnd) + addColon(section(chapterEnd), section(verseEnd));\n  return to ? from + \"-\" + to : from;\n}\n","import { Input } from \"./input\";\nimport { nextStateType, StateType } from \"./transition\";\nimport { toMnemonic, toReference } from \"./outputs\";\nimport { ParseError, errorCheckInput } from \"./errors\";\n\nexport const valueStates = [\n  \"book\",\n  \"chapter\",\n  \"verse\",\n  \"bookEnd\",\n  \"chapterEnd\",\n  \"verseEnd\",\n] as const;\ntype ValueState = typeof valueStates[number];\nconst isValueState = (state: StateType): state is ValueState =>\n  valueStates.indexOf(state as ValueState) !== -1;\n\nexport class State {\n  constructor(state?: State) {\n    if (state) {\n      this.type = state.type;\n      this.testament = state.testament;\n      this.book = state.book;\n      this.chapter = state.chapter;\n      this.verse = state.verse;\n      this.bookEnd = state.bookEnd;\n      this.chapterEnd = state.chapterEnd;\n      this.verseEnd = state.verseEnd;\n      this.inputs = state.inputs;\n      this.string = state.string;\n      this.error = state.error;\n    }\n  }\n  type: StateType = \"initial\";\n  testament: \"o\" | \"n\" | null = null;\n  book: Input | null = null;\n  chapter: Input | null = null;\n  verse: Input | null = null;\n  bookEnd: Input | null = null;\n  chapterEnd: Input | null = null;\n  verseEnd: Input | null = null;\n  inputs: Input[] = [];\n  string: string = \"\";\n  error: ParseError | null = null;\n\n  transition(this: State, input: Input): State {\n    input = this.errorCheckInput(input);\n    const newStateType = nextStateType(this.type, input.type);\n    const newState: State = new State(this);\n    newState.type = newStateType;\n    newState.testament = input.testament || this.testament;\n    newState.inputs = [...this.inputs, input];\n    newState.string = this.string + input.string;\n    newState.error = this.error || input.error;\n    if (input.type === \"number\" && isValueState(newStateType)) {\n      newState[newStateType] = input;\n    }\n    return newState;\n  }\n  inputType(this: State, input: Input): string {\n    for (let valueState of valueStates) {\n      if (this[valueState] === input) return valueState;\n    }\n    return input.type;\n  }\n\n  errorCheckInput(input: Input) {\n    return errorCheckInput(this, input);\n  }\n\n  get reference(): string {\n    return toReference(this);\n  }\n  get mnemonic(): string {\n    return toMnemonic(this);\n  }\n\n  static fromValues(input: PassageDescription) {\n    let state = new State();\n    let doingEnd = false;\n    valueStates.forEach((inputType, index) => {\n      if (!input[inputType]) return null;\n      if (!doingEnd && inputType.includes(\"End\")) {\n        state = state.transition(new Input(\"hyphen\", \"\", null));\n        doingEnd = true;\n      }\n      state = state.transition(\n        new Input(\"number\", \"\", input[inputType] || null, input.testament)\n      );\n    });\n    return state;\n  }\n}\nexport interface PassageDescription {\n  testament: \"o\" | \"n\";\n  book: number;\n  chapter?: number;\n  verse?: number;\n  bookEnd?: number;\n  chapterEnd?: number;\n  verseEnd?: number;\n}\nexport const initialState = new State();\n","import { BadInputError } from \"./errors\";\nimport { State, initialState } from \"./state\";\nimport { nextStateType } from \"./transition\";\nimport { Input } from \"./input\";\nimport { books, bookAbbrvs } from \"../data/books\";\nimport { toNumber } from \"../data/conversion\";\n\nconst parseMultiDigitNumber = (input: string, state: State): Input | null => {\n  const availableDigits = input.match(/^\\d+/);\n  if (!availableDigits) return null;\n  return new Input(\"number\", availableDigits[0], Number(availableDigits[0]));\n};\n\nconst parseBookName = (input: string, testament: \"o\" | \"n\"): Input | null => {\n  const matches = (name: string) =>\n    input.toLowerCase().startsWith(name.toLowerCase());\n  const nameIndex = books[testament].findIndex(matches);\n  const abbrvIndex = bookAbbrvs[testament].findIndex(matches);\n  const nameFound = nameIndex !== -1;\n  const abbrvFound = abbrvIndex !== -1;\n  if (!nameFound && !abbrvFound) return null;\n  const array = nameFound ? books[testament] : bookAbbrvs[testament];\n  const index = nameFound ? nameIndex : abbrvIndex;\n  return new Input(\n    \"number\",\n    input.slice(0, array[index].length),\n    index + 1,\n    testament\n  );\n};\n\nconst whitespaceRegex = /^\\s+/;\nconst parseInput = (state: State, input: string): Input => {\n  if (input === \"\") return new Input(\"end\", \"\", null);\n  if (input.startsWith(\"-\")) return new Input(\"hyphen\", \"-\", null);\n  if (input.startsWith(\":\")) return new Input(\"colon\", \":\", null);\n\n  if (state.type === \"verse\") return new Input(\"end\", \"\", null);\n  if (state.type === \"verseEnd\") return new Input(\"end\", \"\", null);\n\n  if (!state.book) {\n    const ntBookInput = parseBookName(input, \"n\");\n    const otBookInput = parseBookName(input, \"o\");\n    if (ntBookInput) return ntBookInput;\n    if (otBookInput) return otBookInput;\n  }\n\n  const singleLetterNumber = toNumber(input);\n  if (singleLetterNumber) {\n    return new Input(\n      \"number\",\n      input[0],\n      singleLetterNumber,\n      nextStateType(state.type, \"number\") === \"book\" ? \"n\" : null\n    );\n  }\n\n  const numberInput = parseMultiDigitNumber(input, state);\n  if (numberInput) return numberInput;\n\n  const whitespaceMatch = input.match(whitespaceRegex);\n  if (whitespaceMatch) return new Input(\"whitespace\", whitespaceMatch[0], null);\n\n  return new Input(\n    \"error\",\n    input,\n    null,\n    null,\n    new BadInputError(\"Unexpected input \" + input)\n  );\n};\n\nexport const stateFromString = (string: string): State => {\n  let state = initialState;\n  while (true) {\n    const remainingString = string.slice(state.string.length);\n    const input: Input = parseInput(state, remainingString);\n    state = state.transition(input);\n    if (state.type === \"error\" || state.type === \"end\") return state;\n  }\n};\n","import { stateFromString } from \"../parsing/parse\";\nimport { PassageDescription, State } from \"../parsing/state\";\nimport { Input } from \"../parsing/input\";\nimport { books, bookAbbrvs } from \"../data/books\";\nimport { randomWord } from \"../data/words\";\nimport { verseCounts } from \"../data/verses\";\n\nclass Book {\n  constructor(public number: number, public testament: \"o\" | \"n\" = \"n\") {}\n  get name() {\n    return books[this.testament][this.number - 1];\n  }\n  get abbrv() {\n    return bookAbbrvs[this.testament][this.number - 1];\n  }\n}\n\nclass Token {\n  constructor(protected state: State, protected input: Input) {}\n  get type() {\n    return this.state.inputType(this.input);\n  }\n  get string() {\n    return this.input.string;\n  }\n  get value() {\n    return this.input.value;\n  }\n}\n\nconst addUp = (acc: number, val: number) => acc + val;\n\nexport class Passage {\n  constructor(input: string | PassageDescription) {\n    if (typeof input === \"string\") {\n      this.state = stateFromString(input);\n      this.string = this.state.string;\n      this.leftover = input.slice(this.string.length);\n      return this;\n    }\n    this.state = State.fromValues(input);\n    this.string = \"\";\n    this.leftover = \"\";\n  }\n  protected state: State;\n  public string: string;\n  public leftover: string;\n\n  get reference() {\n    return this.state.reference;\n  }\n  get mnemonic() {\n    return this.state.mnemonic;\n  }\n  get verseNumber(): number | null {\n    const { testament, book: bookObj, chapter, verse } = this;\n    if (!testament || !bookObj || !chapter || !verse) return null;\n    const book = bookObj.number;\n    return (\n      (testament === \"n\" ? verseCounts[\"o\"].total : 0) +\n      verseCounts[testament]\n        .slice(0, book - 1)\n        .reduce((acc, book) => acc + book.total, 0) +\n      verseCounts[testament][book - 1].slice(0, chapter - 1).reduce(addUp, 0) +\n      verse\n    );\n  }\n  static get random(): Passage {\n    const n = Math.floor(Math.random() * verseCounts.total);\n    return Passage.nthVerse(n);\n  }\n  static nthVerse(n: number): Passage {\n    const testament = n > verseCounts[\"o\"].total ? \"n\" : \"o\";\n    let count = testament === \"n\" ? verseCounts[\"o\"].total : 0;\n    const book =\n      verseCounts[testament].findIndex((book, index) => {\n        if (count + book.total < n) {\n          count += book.total;\n          return false;\n        }\n        return true;\n      }) + 1;\n    const chapter =\n      verseCounts[testament][book - 1].findIndex((chapterCount, index) => {\n        if (count + chapterCount < n) {\n          count += chapterCount;\n          return false;\n        }\n        return true;\n      }) + 1;\n    const verse = n - count;\n    return new Passage({ testament, book, chapter, verse });\n  }\n\n  get error() {\n    return this.state.error;\n  }\n  get tokens() {\n    return this.state.inputs.map((input) => new Token(this.state, input));\n  }\n\n  get testament() {\n    return this.state.testament;\n  }\n  get book() {\n    const book = this.state.book;\n    return book ? new Book(book.value || 0) : null;\n  }\n  get bookEnd() {\n    const bookEnd = this.state.bookEnd;\n    return bookEnd ? new Book(bookEnd.value || 0) : null;\n  }\n  get chapter() {\n    const chapter = this.state.chapter;\n    return chapter ? chapter.value : null;\n  }\n  get chapterEnd() {\n    const chapterEnd = this.state.chapterEnd;\n    return chapterEnd ? chapterEnd.value : null;\n  }\n  get verse() {\n    const verse = this.state.verse;\n    return verse ? verse.value : null;\n  }\n  get verseEnd() {\n    const verseEnd = this.state.verseEnd;\n    return verseEnd ? verseEnd.value : null;\n  }\n  get endVerse(): Passage {\n    const {\n      testament,\n      book,\n      bookEnd,\n      chapter,\n      chapterEnd,\n      verse,\n      verseEnd,\n    } = this;\n    if (!testament || !book || !(bookEnd || chapterEnd || verseEnd))\n      return this;\n    return new Passage({\n      testament,\n      book: bookEnd?.number || book.number,\n      chapter: chapterEnd || chapter || undefined,\n      verse: verseEnd || verse || undefined,\n    });\n  }\n}\n\nexport const parse = (string: string) => new Passage(string);\n\nexport function randomWordPassage(oddity: number) {\n  while (true) {\n    const word = randomWord(oddity);\n    const passage = new Passage(word);\n    if (!passage.error) return passage;\n  }\n}\n","import React, { useMemo, useRef, useState } from \"react\";\nimport { PassageTokens } from \"./components/PassageTokens\";\nimport { filterWords } from \"./data/words\";\nimport { randomWordPassage, parse, Passage } from \"./passage/passage\";\n\nconst maxWords = 1000;\n\nconsole.log(Passage);\n\nfunction App() {\n  const [input, setInput] = useState(\"\");\n  const [oddity, setOddity] = useState(3);\n  const [showSlider, setShowSlider] = useState(false);\n  const passage = parse(input);\n  const { reference, mnemonic, error } = passage;\n  const refEntered = input && input.includes(reference);\n  const linkRef = useRef<HTMLAnchorElement>(null);\n\n  const matches = useMemo(\n    () => filterWords({ startsWith: mnemonic, oddity, maxWords }),\n    [mnemonic, oddity]\n  );\n\n  const showMnemonics =\n    (input === mnemonic || refEntered) &&\n    (passage.verse || passage.testament === \"o\");\n\n  const randomVerse = () => setInput(randomWordPassage(1).reference);\n  const randomWord = () => {\n    const passage = randomWordPassage(1);\n    setInput(passage.string + passage.leftover);\n  };\n\n  return (\n    <div className=\"App\">\n      <button onClick={randomWord}>Random word</button>\n      <button onClick={randomVerse}>Random verse</button>\n      <br />\n      Input:{\" \"}\n      <input\n        type=\"text\"\n        value={input}\n        onKeyPress={(e) => e.key === \"Enter\" && linkRef.current?.click()}\n        onChange={(e) => setInput(e.target.value)}\n      />{\" \"}\n      {input !== \"\" && !passage.error && (\n        <a\n          className=\"hint\"\n          ref={linkRef}\n          target=\"_blank\"\n          rel=\"noopener noreferrer\"\n          href={`https://www.biblegateway.com/passage/?search=${reference.replace(\n            \" \",\n            \"+\"\n          )}&version=ESV`}\n        >\n          <span role=\"img\" aria-label=\"link\">\n            🔗\n          </span>\n        </a>\n      )}\n      <p>\n        <PassageTokens passage={passage} />\n      </p>\n      <p>{error?.toString()}</p>\n      {input !== \"\" && !refEntered && (\n        <p>\n          Reference: <PassageTokens passage={parse(reference)} />\n        </p>\n      )}\n      {showMnemonics && (\n        <div>\n          <span onClick={() => setShowSlider((a) => !a)}>\n            {matches.length > 0 ? (\n              <>\n                {matches.length === maxWords\n                  ? matches.length + \"+\"\n                  : matches.length}{\" \"}\n                potential <PassageTokens passage={parse(mnemonic)} /> mnemonic\n                {matches.length > 1 && \"s\"}\n              </>\n            ) : (\n              <>\n                No matching <PassageTokens passage={parse(mnemonic)} /> words\n                found.\n                <p className=\"hint\">\n                  Maybe it's an acronym? Good mental hooks take creativity!\n                </p>\n              </>\n            )}\n          </span>\n          {showSlider && (\n            <div>\n              Word strangeness:{\" \"}\n              <input\n                type=\"range\"\n                value={oddity}\n                min={0}\n                max={7}\n                onChange={(e) => setOddity(Number(e.target.value))}\n              />\n            </div>\n          )}\n          {matches.map((word, index) => (\n            <p key={index + word} style={{ margin: \"5px\" }}>\n              <small>{word}</small>\n            </p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default App;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}