{"version":3,"sources":["components/PassageTokens.tsx","data/words.ts","data/verses.ts","parsing/transition.ts","parsing/input.ts","parsing/errors.ts","data/books.ts","data/conversion.ts","functions/invertObject.ts","parsing/outputs.ts","parsing/state.ts","parsing/parse.ts","passage/passage.ts","components/NETPassage.tsx","functions/useFetch.ts","Link.tsx","App.tsx","functions/random.ts","index.tsx"],"names":["PassageTokens","props","passage","tokens","leftover","className","map","token","index","key","type","string","wordGroups","english_10","british_10","english_20","british_20","english_35","british_35","english_40","british_40","english_50","british_50","english_55","british_55","english_60","british_60","english_70","british_70","randomElement","array","Math","floor","random","length","randomWord","oddity","clamped","max","min","slice","wordExists","filters","startsWith","group","match","find","word","bookWithTotal","cumulative","total","reduce","acc","val","Object","assign","totalUp","testament","totalled","book","withTotal","otVerseCounts","otVerseCountsPure","ntVerseCounts","ntVerseCountsPure","verseCounts","o","n","transitionMatrix","initial","number","chapter","colon","hyphen","verse","chapterHyphen","bookEnd","chapterEnd","verseEnd","error","end","nextStateType","stateType","inputType","Input","value","ParseError","message","name","Error","BoundsError","BadInputError","inputValueError","state","input","next","inputMinValue","inputMaxValue","boundType","endsWith","inRef","reference","otBooks","ntBooks","books","bookAbbrvs","turkishLetterNumbers","Ã§","ÅŸ","Ã¶","Ã¼","Ã‡","Åž","Ã–","Ãœ","reverse","object","ret","keys","forEach","String","invertObject","toMnemonic","section","fromCodePoint","toString","bookSection","toLowerCase","addColon","a","b","test","from","to","valueStates","State","inputs","this","errorCheckInput","newStateType","newState","indexOf","valueState","sectionTo","toReference","doingEnd","includes","transition","initialState","parseBookName","matches","nameIndex","findIndex","abbrvIndex","nameFound","whitespaceRegex","parseInput","ntBookInput","otBookInput","singleLetterNumber","codepoint","codePointAt","toNumber","numberInput","availableDigits","Number","parseMultiDigitNumber","whitespaceMatch","Book","Token","addUp","Passage","remainingString","stateFromString","fromValues","mnemonic","bookObj","undefined","count","chapterCount","nthVerse","parse","NETPassage","url","useState","data","setData","useEffect","current","fetchJsonp","then","r","json","catch","console","log","useFetch","urlOf","response","verses","text","replace","href","ref","encodeURI","Link","React","forwardRef","target","rel","role","aria-label","maxWords","defaultInput","URLSearchParams","window","location","search","get","App","setInput","setOddity","showSlider","setShowSlider","refEntered","valid","linkRef","useRef","useMemo","filteredWords","groupOddity","push","sort","filterWords","showMnemonics","onClick","randomWordPassage","randomPassageReference","onKeyPress","e","click","onChange","style","margin","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.5de6c7fa.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./PassageTokens.css\";\nimport { Passage } from \"../passage/passage\";\n\nexport const PassageTokens = (props: { passage: Passage }) => {\n  const { tokens, leftover } = props.passage;\n  return (\n    <span className=\"parsedPassage\">\n      {tokens.map((token, index) => (\n        <span key={index} className={token.type + \"Token\"}>\n          {token.string}\n        </span>\n      ))}\n      {leftover}\n    </span>\n  );\n};\n","import english_10 from \"wordlist-english/english-words-10.json\";\nimport english_20 from \"wordlist-english/english-words-20.json\";\nimport english_35 from \"wordlist-english/english-words-35.json\";\nimport english_40 from \"wordlist-english/english-words-40.json\";\nimport english_50 from \"wordlist-english/english-words-50.json\";\nimport english_55 from \"wordlist-english/english-words-55.json\";\nimport english_60 from \"wordlist-english/english-words-60.json\";\nimport english_70 from \"wordlist-english/english-words-70.json\";\nimport british_10 from \"wordlist-english/british-words-10.json\";\nimport british_20 from \"wordlist-english/british-words-20.json\";\nimport british_35 from \"wordlist-english/british-words-35.json\";\nimport british_40 from \"wordlist-english/british-words-40.json\";\nimport british_50 from \"wordlist-english/british-words-50.json\";\nimport british_55 from \"wordlist-english/british-words-55.json\";\nimport british_60 from \"wordlist-english/british-words-60.json\";\nimport british_70 from \"wordlist-english/british-words-70.json\";\n\nconst wordGroups = [\n  [...english_10, ...british_10],\n  [...english_20, ...british_20],\n  [...english_35, ...british_35],\n  [...english_40, ...british_40],\n  [...english_50, ...british_50],\n  [...english_55, ...british_55],\n  [...english_60, ...british_60],\n  [...english_70, ...british_70],\n];\n\nfunction randomElement<T>(array: T[]): T {\n  return array[Math.floor(Math.random() * array.length)];\n}\n\nexport function randomWord(oddity = 0): string {\n  const clamped = Math.max(0, Math.min(7, oddity));\n  return randomElement(randomElement(wordGroups.slice(0, clamped + 1)));\n}\n\ninterface Filters {\n  oddity?: number;\n  startsWith?: string;\n  maxWords?: number;\n}\nexport function wordExists(filters: Filters = {}): string | false {\n  const { oddity = 0, startsWith = \"\" } = filters;\n  for (let group = 0; group < wordGroups.length; group++) {\n    if (group > oddity) return false;\n    const match = wordGroups[group].find((word) => word.startsWith(startsWith));\n    if (match) return match;\n  }\n  return false;\n}\nexport function filterWords(filters: Filters = {}): string[] {\n  const { oddity = 0, startsWith, maxWords = 1000 } = filters;\n  const filteredWords: string[] = [];\n  wordGroups.forEach(\n    (group, groupOddity) =>\n      groupOddity <= oddity &&\n      group.forEach(\n        (word) =>\n          filteredWords.length < maxWords &&\n          (startsWith ? word.startsWith(startsWith) : true) &&\n          filteredWords.push(word)\n      )\n  );\n  return filteredWords.sort();\n}\n","import otVerseCountsPure from \"./otVerseCounts.json\";\nimport ntVerseCountsPure from \"./ntVerseCounts.json\";\n\ntype TotalledArray<T> = T[] & {\n  total: number;\n  cumulative: number;\n};\n\ntype Book = number[];\ntype Testament = Book[];\n\nfunction bookWithTotal(array: Book, cumulative: number): TotalledArray<number> {\n  const total = array.reduce((acc, val) => acc + val);\n  return Object.assign(array, { total, cumulative: cumulative + total });\n}\n\nconst totalUp = (\n  testament: Testament,\n  cumulative = 0\n): TotalledArray<TotalledArray<number>> => {\n  const totalled = testament.map((book) => {\n    const withTotal = bookWithTotal(book, cumulative);\n    cumulative += withTotal.total;\n    return withTotal;\n  });\n  const total = totalled.reduce((acc, book) => acc + book.total, 0);\n  return Object.assign(totalled, { total, cumulative });\n};\n\nexport const otVerseCounts: TotalledArray<TotalledArray<number>> = totalUp(\n  otVerseCountsPure as number[][]\n);\nexport const ntVerseCounts: TotalledArray<TotalledArray<number>> = totalUp(\n  ntVerseCountsPure as number[][],\n  otVerseCounts.total\n);\n\nexport const verseCounts = {\n  o: otVerseCounts,\n  n: ntVerseCounts,\n  total: otVerseCounts.total + ntVerseCounts.total,\n  cumulative: ntVerseCounts.cumulative,\n};\n","export type StateType =\n  | \"initial\"\n  | \"book\"\n  | \"chapter\"\n  | \"verse\"\n  | \"chapterHyphen\"\n  | \"bookEnd\"\n  | \"chapterEnd\"\n  | \"verseEnd\"\n  | \"error\"\n  | \"end\";\n\nexport type InputType =\n  | \"number\"\n  | \"hyphen\"\n  | \"whitespace\"\n  | \"end\"\n  | \"error\"\n  | \"colon\";\n\ntype StateTransition = {\n  readonly [E in InputType]?: StateType;\n};\ntype TransitionMatrix = {\n  readonly [E in StateType]: StateTransition;\n};\n\nconst transitionMatrix: TransitionMatrix = {\n  initial: {\n    number: \"book\",\n  },\n  book: {\n    number: \"chapter\",\n  },\n  chapter: {\n    number: \"verse\",\n    colon: \"chapter\",\n    hyphen: \"chapterHyphen\",\n  },\n  verse: {\n    hyphen: \"chapterEnd\", // or ChapterHyphen! Change to array when upgrading to have paths\n  },\n  chapterHyphen: {\n    number: \"chapterEnd\",\n  },\n  bookEnd: {},\n  chapterEnd: {\n    number: \"verseEnd\",\n    colon: \"chapterEnd\",\n  },\n  verseEnd: {},\n  error: {},\n  end: {},\n};\n\nexport function nextStateType(\n  stateType: StateType,\n  inputType: InputType\n): StateType {\n  return inputType === \"end\"\n    ? \"end\"\n    : transitionMatrix[stateType][inputType] ||\n        (inputType === \"whitespace\" ? stateType : \"error\");\n}\n","import { InputType } from \"./transition\";\nimport { ParseError } from \"./errors\";\n\nexport class Input {\n  constructor(\n    readonly type: InputType,\n    readonly string: string,\n    readonly value: number | null,\n    readonly testament: \"o\" | \"n\" | null = null,\n    readonly error: ParseError | null = null\n  ) {}\n}\n","import { State } from \"./state\";\nimport { ntVerseCounts, otVerseCounts } from \"../data/verses\";\nimport { nextStateType } from \"./transition\";\nimport { Input } from \"./input\";\n\nexport abstract class ParseError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"ParseError\";\n  }\n}\nexport class BoundsError extends ParseError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"BoundsError\";\n  }\n}\nexport class BadInputError extends ParseError {\n  constructor(message: string) {\n    super(message);\n    this.name = \"BadInputError\";\n  }\n}\n\nfunction inputMaxValue(state: State, input: Input): number {\n  const book = (state.bookEnd || state.book)?.value || 1;\n  const chapter = (state.chapterEnd || state.chapter)?.value || 1;\n  const verseCounts =\n    (state.testament || input.testament) === \"o\"\n      ? otVerseCounts\n      : ntVerseCounts;\n  const next = nextStateType(state.type, \"number\");\n  if (next === \"book\" || next === \"bookEnd\") return verseCounts.length;\n  if (next === \"chapter\" || next === \"chapterEnd\")\n    return verseCounts[book - 1].length;\n  if (next === \"verse\" || next === \"verseEnd\")\n    return verseCounts[book - 1][chapter - 1];\n  return 0;\n}\nfunction inputMinValue(state: State, input: Input): number {\n  const next = nextStateType(state.type, \"number\");\n  const book = state.book?.value || -1;\n  const chapter = state.chapter?.value || -1;\n  const verse = state.verse?.value || -1;\n  if (next === \"bookEnd\") return book + 1;\n  if (next === \"chapterEnd\") return chapter + 1;\n  if (next === \"verseEnd\") return verse + 1;\n  return 0;\n}\n\nfunction inputValueError(state: State, input: Input): Error | null {\n  const min = inputMinValue(state, input);\n  const max = inputMaxValue(state, input);\n  const value = input.value || 0;\n  const next = nextStateType(state.type, \"number\");\n  const boundType = next.endsWith(\"End\") ? next.slice(0, -3) : next;\n\n  if (max < min) return new BoundsError(`No valid ${boundType}`);\n  if (value < min)\n    return new BoundsError(`${boundType} must be over ${min - 1}`);\n  if (value > max) {\n    const inRef = state.reference ? \"in \" + state.reference : \"\";\n    return new BoundsError(\n      `${value} is over maximum of ${max} ${boundType}s ${inRef}`\n    );\n  }\n  return null;\n}\n\nexport function errorCheckInput(state: State, input: Input): Input {\n  const { type, string, value, testament } = input;\n  if (type !== \"number\") return input;\n  const error = inputValueError(state, input);\n  if (!error) return input;\n  return new Input(\"error\", string, value, testament, error);\n}\n","export const otBooks = [\n  \"Genesis\",\n  \"Exodus\",\n  \"Leviticus\",\n  \"Numbers\",\n  \"Deuteronomy\",\n  \"Joshua\",\n  \"Judges\",\n  \"Ruth\",\n  \"1 Samuel\",\n  \"2 Samuel\",\n  \"1 Kings\",\n  \"2 Kings\",\n  \"1 Chronicles\",\n  \"2 Chronicles\",\n  \"Ezra\",\n  \"Nehemiah\",\n  \"Esther\",\n  \"Job\",\n  \"Psalm\",\n  \"Proverbs\",\n  \"Ecclesiastes\",\n  \"Song of Songs\",\n  \"Isaiah\",\n  \"Jeremiah\",\n  \"Lamentations\",\n  \"Ezekiel\",\n  \"Daniel\",\n  \"Hosea\",\n  \"Joel\",\n  \"Amos\",\n  \"Obadiah\",\n  \"Jonah\",\n  \"Micah\",\n  \"Nahum\",\n  \"Habakkuk\",\n  \"Zephaniah\",\n  \"Haggai\",\n  \"Zechariah\",\n  \"Malachi\",\n];\n\nexport const ntBooks = [\n  \"Matthew\",\n  \"Mark\",\n  \"Luke\",\n  \"John\",\n  \"Acts\",\n  \"Romans\",\n  \"1 Corinthians\",\n  \"2 Corinthians\",\n  \"Galatians\",\n  \"Ephesians\",\n  \"Philippians\",\n  \"Colossians\",\n  \"1 Thessalonians\",\n  \"2 Thessalonians\",\n  \"1 Timothy\",\n  \"2 Timothy\",\n  \"Titus\",\n  \"Philemon\",\n  \"Hebrews\",\n  \"James\",\n  \"1 Peter\",\n  \"2 Peter\",\n  \"1 John\",\n  \"2 John\",\n  \"3 John\",\n  \"Jude\",\n  \"Revelation\",\n];\n\nexport const otBookAbbrvs = [\n  \"Gen\",\n  \"Exo\",\n  \"Lev\",\n  \"Num\",\n  \"Deu\",\n  \"Jos\",\n  \"Jud\",\n  \"Ru\",\n  \"1S\",\n  \"2S\",\n  \"1K\",\n  \"2K\",\n  \"1C\",\n  \"2C\",\n  \"Ezr\",\n  \"Neh\",\n  \"Est\",\n  \"Job\",\n  \"Ps\",\n  \"Pr\",\n  \"Ecc\",\n  \"Son\",\n  \"Is\",\n  \"Jer\",\n  \"Lam\",\n  \"Eze\",\n  \"Dan\",\n  \"Hos\",\n  \"Joe\",\n  \"Amo\",\n  \"Oba\",\n  \"Jon\",\n  \"Mic\",\n  \"Nah\",\n  \"Hab\",\n  \"Zep\",\n  \"Hag\",\n  \"Zec\",\n  \"Mal\",\n];\n\nexport const ntBookAbbrvs = [\n  \"Mat\",\n  \"Mk\",\n  \"Lk\",\n  \"Jn\",\n  \"Acts\",\n  \"Rom\",\n  \"1Cor\",\n  \"2Cor\",\n  \"Gala\",\n  \"Ephe\",\n  \"Colo\",\n  \"Phi\",\n  \"1Th\",\n  \"2Th\",\n  \"1Ti\",\n  \"2Ti\",\n  \"Ti\",\n  \"Phm\",\n  \"Heb\",\n  \"Js\",\n  \"1P\",\n  \"2P\",\n  \"1J\",\n  \"2J\",\n  \"3J\",\n  \"Jude\",\n  \"Rev\",\n];\nexport const books = {\n  o: otBooks,\n  n: ntBooks,\n};\nexport const bookAbbrvs = {\n  o: otBookAbbrvs,\n  n: ntBookAbbrvs,\n};\n","import { invertObject } from \"../functions/invertObject\";\n\nconst turkishLetterNumbers = {\n  Ã§: 27,\n  ÅŸ: 28,\n  Ã¶: 29,\n  Ã¼: 30,\n  Ã‡: 57,\n  Åž: 58,\n  Ã–: 59,\n  Ãœ: 60,\n} as const;\n\nconst reverse = invertObject(turkishLetterNumbers);\n\nexport const toNumber = (input: string): number | null => {\n  const codepoint = input.codePointAt(0);\n  if (!codepoint) return null;\n  if (input.match(/^[a-z]/)) return codepoint - 96;\n  if (input.match(/^[A-Z]/)) return codepoint - 34;\n  if (input.match(/^0/)) return 30;\n  if (input.match(/^[Ã§Ã‡ÅŸÅžÃ¶Ã–Ã¼Ãœ]/))\n    return turkishLetterNumbers[input[0] as keyof typeof turkishLetterNumbers];\n  return null;\n};\n\nexport const toString = (input: number): string | null => {\n  if (reverse[input]) return reverse[input];\n  if (input >= 1 && input <= 26) return String.fromCodePoint(input + 96);\n  if (input >= 31 && input <= 56) return String.fromCodePoint(input + 34);\n  return null;\n};\n","export function invertObject<O extends { [index: string]: number | string }>(\n  object: O\n): {\n  [index: string]: string;\n} {\n  const ret: { [index: string]: string } = {};\n  Object.keys(object).forEach((key) => {\n    ret[object[String(key)]] = key;\n  });\n  return ret;\n}\n","import { bookAbbrvs, ntBooks, otBooks } from \"../data/books\";\nimport { toString } from \"../data/conversion\";\nimport { Input } from \"./input\";\nimport { State } from \"./state\";\n\nexport function toReference(state: State) {\n  const {\n    testament,\n    book,\n    chapter,\n    verse,\n    bookEnd,\n    chapterEnd,\n    verseEnd,\n  } = state;\n  const books = testament === \"o\" ? otBooks : ntBooks;\n  const sectionTo =\n    (bookEnd ? books[(bookEnd.value || 1) - 1] + \" \" : \"\") +\n    (chapterEnd?.value || \"\") +\n    (chapterEnd && verseEnd ? \":\" : \"\") +\n    (verseEnd?.value || \"\");\n  return (\n    (book ? books[(book.value || 1) - 1] : \"\") +\n    (chapter ? \" \" + chapter.value : \"\") +\n    (verse ? \":\" + verse.value : \"\") +\n    (sectionTo ? \"-\" + sectionTo : \"\")\n  );\n}\n\nexport function toMnemonic(state: State): string {\n  const {\n    testament,\n    book,\n    chapter,\n    verse,\n    bookEnd,\n    chapterEnd,\n    verseEnd,\n  } = state;\n  const section = (input: Input | null): string =>\n    (input?.value && toString(input?.value)) || input?.value?.toString() || \"\";\n  const otBook = (input: Input | null): string =>\n    ((input?.value && bookAbbrvs[\"o\"][input?.value - 1]) || \"\").toLowerCase();\n  const bookSection = testament === \"n\" ? section : otBook;\n  const addColon = (a: string, b: string) =>\n    /\\d+/.test(a) && /\\d+/.test(b) ? a + \":\" + b : a + b;\n  const from = bookSection(book) + addColon(section(chapter), section(verse));\n  const to =\n    bookSection(bookEnd) + addColon(section(chapterEnd), section(verseEnd));\n  return to ? from + \"-\" + to : from;\n}\n","import { Input } from \"./input\";\nimport { nextStateType, StateType } from \"./transition\";\nimport { toMnemonic, toReference } from \"./outputs\";\nimport { ParseError, errorCheckInput } from \"./errors\";\n\nexport const valueStates = [\n  \"book\",\n  \"chapter\",\n  \"verse\",\n  \"bookEnd\",\n  \"chapterEnd\",\n  \"verseEnd\",\n] as const;\ntype ValueState = typeof valueStates[number];\nconst isValueState = (state: StateType): state is ValueState =>\n  valueStates.indexOf(state as ValueState) !== -1;\n\nexport class State {\n  constructor(state?: State) {\n    if (state) {\n      this.type = state.type;\n      this.testament = state.testament;\n      this.book = state.book;\n      this.chapter = state.chapter;\n      this.verse = state.verse;\n      this.bookEnd = state.bookEnd;\n      this.chapterEnd = state.chapterEnd;\n      this.verseEnd = state.verseEnd;\n      this.inputs = state.inputs;\n      this.string = state.string;\n      this.error = state.error;\n    }\n  }\n  type: StateType = \"initial\";\n  testament: \"o\" | \"n\" | null = null;\n  book: Input | null = null;\n  chapter: Input | null = null;\n  verse: Input | null = null;\n  bookEnd: Input | null = null;\n  chapterEnd: Input | null = null;\n  verseEnd: Input | null = null;\n  inputs: Input[] = [];\n  string: string = \"\";\n  error: ParseError | null = null;\n\n  transition(this: State, input: Input): State {\n    input = this.errorCheckInput(input);\n    const newStateType = nextStateType(this.type, input.type);\n    const newState: State = new State(this);\n    newState.type = newStateType;\n    newState.testament = input.testament || this.testament;\n    newState.inputs = [...this.inputs, input];\n    newState.string = this.string + input.string;\n    newState.error = this.error || input.error;\n    if (input.type === \"number\" && isValueState(newStateType)) {\n      newState[newStateType] = input;\n    }\n    return newState;\n  }\n  inputType(this: State, input: Input): string {\n    for (let valueState of valueStates) {\n      if (this[valueState] === input) return valueState;\n    }\n    return input.type;\n  }\n\n  errorCheckInput(input: Input) {\n    return errorCheckInput(this, input);\n  }\n\n  get reference(): string {\n    return toReference(this);\n  }\n  get mnemonic(): string {\n    return toMnemonic(this);\n  }\n\n  static fromValues(input: PassageDescription) {\n    let state = new State();\n    let doingEnd = false;\n    valueStates.forEach((inputType, index) => {\n      if (!input[inputType]) return null;\n      if (!doingEnd && inputType.includes(\"End\")) {\n        state = state.transition(new Input(\"hyphen\", \"\", null));\n        doingEnd = true;\n      }\n      state = state.transition(\n        new Input(\"number\", \"\", input[inputType] || null, input.testament)\n      );\n    });\n    return state;\n  }\n}\nexport interface PassageDescription {\n  testament: \"o\" | \"n\";\n  book: number;\n  chapter?: number;\n  verse?: number;\n  bookEnd?: number;\n  chapterEnd?: number;\n  verseEnd?: number;\n}\nexport const initialState = new State();\n","import { BadInputError } from \"./errors\";\nimport { State, initialState } from \"./state\";\nimport { nextStateType } from \"./transition\";\nimport { Input } from \"./input\";\nimport { books, bookAbbrvs } from \"../data/books\";\nimport { toNumber } from \"../data/conversion\";\n\nconst parseMultiDigitNumber = (input: string, state: State): Input | null => {\n  const availableDigits = input.match(/^\\d+/);\n  if (!availableDigits) return null;\n  return new Input(\"number\", availableDigits[0], Number(availableDigits[0]));\n};\n\nconst parseBookName = (input: string, testament: \"o\" | \"n\"): Input | null => {\n  const matches = (name: string) =>\n    input.toLowerCase().startsWith(name.toLowerCase());\n  const nameIndex = books[testament].findIndex(matches);\n  const abbrvIndex = bookAbbrvs[testament].findIndex(matches);\n  const nameFound = nameIndex !== -1;\n  const abbrvFound = abbrvIndex !== -1;\n  if (!nameFound && !abbrvFound) return null;\n  const array = nameFound ? books[testament] : bookAbbrvs[testament];\n  const index = nameFound ? nameIndex : abbrvIndex;\n  return new Input(\n    \"number\",\n    input.slice(0, array[index].length),\n    index + 1,\n    testament\n  );\n};\n\nconst whitespaceRegex = /^\\s+/;\nconst parseInput = (state: State, input: string): Input => {\n  if (input === \"\") return new Input(\"end\", \"\", null);\n  if (input.startsWith(\"-\")) return new Input(\"hyphen\", \"-\", null);\n  if (input.startsWith(\":\")) return new Input(\"colon\", \":\", null);\n\n  if (state.type === \"verse\") return new Input(\"end\", \"\", null);\n  if (state.type === \"verseEnd\") return new Input(\"end\", \"\", null);\n\n  if (!state.book) {\n    const ntBookInput = parseBookName(input, \"n\");\n    const otBookInput = parseBookName(input, \"o\");\n    if (ntBookInput) return ntBookInput;\n    if (otBookInput) return otBookInput;\n  }\n\n  const singleLetterNumber = toNumber(input);\n  if (singleLetterNumber) {\n    return new Input(\n      \"number\",\n      input[0],\n      singleLetterNumber,\n      nextStateType(state.type, \"number\") === \"book\" ? \"n\" : null\n    );\n  }\n\n  const numberInput = parseMultiDigitNumber(input, state);\n  if (numberInput) return numberInput;\n\n  const whitespaceMatch = input.match(whitespaceRegex);\n  if (whitespaceMatch) return new Input(\"whitespace\", whitespaceMatch[0], null);\n\n  return new Input(\n    \"error\",\n    input,\n    null,\n    null,\n    new BadInputError(\"Unexpected input \" + input)\n  );\n};\n\nexport const stateFromString = (string: string): State => {\n  let state = initialState;\n  while (true) {\n    const remainingString = string.slice(state.string.length);\n    const input: Input = parseInput(state, remainingString);\n    state = state.transition(input);\n    if (state.type === \"error\" || state.type === \"end\") return state;\n  }\n};\n","import { stateFromString } from \"../parsing/parse\";\nimport { PassageDescription, State } from \"../parsing/state\";\nimport { Input } from \"../parsing/input\";\nimport { books, bookAbbrvs } from \"../data/books\";\nimport { verseCounts } from \"../data/verses\";\n\nclass Book {\n  constructor(public number: number, public testament: \"o\" | \"n\" = \"n\") {}\n  get name() {\n    return books[this.testament][this.number - 1];\n  }\n  get abbrv() {\n    return bookAbbrvs[this.testament][this.number - 1];\n  }\n}\n\nclass Token {\n  constructor(protected state: State, protected input: Input) {}\n  get type() {\n    return this.state.inputType(this.input);\n  }\n  get string() {\n    return this.input.string;\n  }\n  get value() {\n    return this.input.value;\n  }\n}\n\nconst addUp = (acc: number, val: number) => acc + val;\n\nexport class Passage {\n  constructor(input: string | PassageDescription) {\n    if (typeof input === \"string\") {\n      this.state = stateFromString(input);\n      this.string = this.state.string;\n      this.leftover = input.slice(this.string.length);\n      return this;\n    }\n    this.state = State.fromValues(input);\n    this.string = \"\";\n    this.leftover = \"\";\n  }\n  protected state: State;\n  public string: string;\n  public leftover: string;\n\n  get reference() {\n    return this.state.reference;\n  }\n  get mnemonic() {\n    return this.state.mnemonic;\n  }\n  get verseNumber(): number | null {\n    const { testament, book: bookObj, chapter, verse } = this;\n    if (!testament || !bookObj || !chapter || !verse) return null;\n    const book = bookObj.number;\n    return (\n      (testament === \"n\" ? verseCounts[\"o\"].total : 0) +\n      verseCounts[testament]\n        .slice(0, book - 1)\n        .reduce((acc, book) => acc + book.total, 0) +\n      verseCounts[testament][book - 1].slice(0, chapter - 1).reduce(addUp, 0) +\n      verse\n    );\n  }\n  static get random(): Passage {\n    const n = Math.floor(Math.random() * verseCounts.total);\n    return Passage.nthVerse(n);\n  }\n  static nthVerse(n: number): Passage {\n    const testament = n > verseCounts[\"o\"].total ? \"n\" : \"o\";\n    let count = testament === \"n\" ? verseCounts[\"o\"].total : 0;\n    const book =\n      verseCounts[testament].findIndex((book, index) => {\n        if (count + book.total < n) {\n          count += book.total;\n          return false;\n        }\n        return true;\n      }) + 1;\n    const chapter =\n      verseCounts[testament][book - 1].findIndex((chapterCount, index) => {\n        if (count + chapterCount < n) {\n          count += chapterCount;\n          return false;\n        }\n        return true;\n      }) + 1;\n    const verse = n - count;\n    return new Passage({ testament, book, chapter, verse });\n  }\n\n  get error() {\n    return this.state.error;\n  }\n  get tokens() {\n    return this.state.inputs.map((input) => new Token(this.state, input));\n  }\n\n  get testament() {\n    return this.state.testament;\n  }\n  get book() {\n    const book = this.state.book;\n    return book ? new Book(book.value || 0) : null;\n  }\n  get bookEnd() {\n    const bookEnd = this.state.bookEnd;\n    return bookEnd ? new Book(bookEnd.value || 0) : null;\n  }\n  get chapter() {\n    const chapter = this.state.chapter;\n    return chapter ? chapter.value : null;\n  }\n  get chapterEnd() {\n    const chapterEnd = this.state.chapterEnd;\n    return chapterEnd ? chapterEnd.value : null;\n  }\n  get verse() {\n    const verse = this.state.verse;\n    return verse ? verse.value : null;\n  }\n  get verseEnd() {\n    const verseEnd = this.state.verseEnd;\n    return verseEnd ? verseEnd.value : null;\n  }\n  get endVerse(): Passage {\n    const {\n      testament,\n      book,\n      bookEnd,\n      chapter,\n      chapterEnd,\n      verse,\n      verseEnd,\n    } = this;\n    if (!testament || !book || !(bookEnd || chapterEnd || verseEnd))\n      return this;\n    return new Passage({\n      testament,\n      book: bookEnd?.number || book.number,\n      chapter: chapterEnd || chapter || undefined,\n      verse: verseEnd || verse || undefined,\n    });\n  }\n}\n\nexport const parse = (string: string) => new Passage(string);\n","import React from \"react\";\nimport { useFetch } from \"../functions/useFetch\";\n\nexport function NETPassage(props: { reference: string | null }) {\n  const { reference } = props;\n  const url = reference ? urlOf(reference) : \"\";\n  const [response] = useFetch<Verse[]>(url);\n  return (\n    <>\n      {response?.map((passage, index, verses) => (\n        <p key={passage.verse + passage.chapter + index} className=\"hint\">\n          {passage.text\n            .slice(0, passage.text.indexOf(\"<a style=\"))\n            .replace(/<\\/?[\\w]+?\\/?>/g, \"\")}\n          {index === verses.length - 1 && (\n            <a href=\"https://labs.bible.org/api_web_service#\">\n              <b>&copy;NET</b>\n            </a>\n          )}\n        </p>\n      ))}\n      {response && <br />}\n    </>\n  );\n}\nconst urlOf = (ref: string) =>\n  \"https://labs.bible.org/api/?passage=\" + encodeURI(ref) + \"&type=json\";\ninterface Verse {\n  text: string;\n  book: string;\n  verse: string;\n  chapter: string;\n}\n","import fetchJsonp from \"fetch-jsonp\";\nimport { useState, useEffect } from \"react\";\n\nexport const useFetch = <T>(url: string) => {\n  const [data, setData] = useState<T | null>(null);\n\n  useEffect(() => {\n    if (!url) return setData(null);\n    let current = true;\n    fetchJsonp(url)\n      .then((r) => r.json())\n      .then((json) => current && setData(json as T))\n      .catch((error) => {\n        if (current) setData(null);\n        console.log(error);\n      });\n    return () => {\n      current = false;\n    };\n  }, [url]);\n\n  return [data];\n};\n","import React from \"react\";\n\nexport const Link = React.forwardRef<HTMLAnchorElement, { reference: string }>(\n  (props, ref) => (\n    <a\n      className=\"hint\"\n      ref={ref}\n      target=\"_blank\"\n      rel=\"noopener noreferrer\"\n      href={`https://www.biblegateway.com/passage/?search=${props.reference.replace(\n        \" \",\n        \"+\"\n      )}&version=ESV`}\n    >\n      <span role=\"img\" aria-label=\"link\">\n        ðŸ”—\n      </span>\n    </a>\n  )\n);\n","import React, { useMemo, useRef, useState } from \"react\";\nimport { PassageTokens } from \"./components/PassageTokens\";\nimport { filterWords } from \"./data/words\";\nimport { parse } from \"./passage/passage\";\nimport { randomWordPassage, randomPassageReference } from \"./functions/random\";\nimport { NETPassage } from \"./components/NETPassage\";\nimport { Link } from \"./Link\";\n\nfunction App() {\n  const [input, setInput] = useState(defaultInput);\n  const [oddity, setOddity] = useState(3);\n  const [showSlider, setShowSlider] = useState(false);\n  const passage = parse(input);\n  const { reference, mnemonic, error } = passage;\n  const refEntered = input && input.includes(reference);\n  const valid = input !== \"\" && !passage.error;\n  const linkRef = useRef<HTMLAnchorElement>(null);\n  const matches = useMemo(\n    () => filterWords({ startsWith: mnemonic, oddity, maxWords }),\n    [mnemonic, oddity]\n  );\n\n  const showMnemonics =\n    (input === mnemonic || refEntered) &&\n    (passage.verse || passage.testament === \"o\");\n\n  const randomWord = () => {\n    const passage = randomWordPassage(1);\n    setInput(passage.string + passage.leftover);\n  };\n  const randomVerse = () => setInput(randomPassageReference(oddity));\n\n  return (\n    <div className=\"App\">\n      <button onClick={randomWord}>Random word</button>{\" \"}\n      <button onClick={randomVerse}>Random verse</button>\n      <br />\n      Input:{\" \"}\n      <input\n        type=\"text\"\n        value={input}\n        onKeyPress={(e) => e.key === \"Enter\" && linkRef.current?.click()}\n        onChange={(e) => setInput(e.target.value)}\n      />{\" \"}\n      <Link ref={linkRef} reference={reference} />\n      <p>\n        <PassageTokens passage={passage} />\n      </p>\n      <p>{error?.toString()}</p>\n      {valid && !refEntered && (\n        <p onClick={() => setInput(reference)}>\n          Reference: <PassageTokens passage={parse(reference)} />\n        </p>\n      )}\n      {valid && refEntered && (\n        <p>\n          Mnemonic: <PassageTokens passage={parse(mnemonic)} />\n        </p>\n      )}\n      {valid && (\n        <NETPassage reference={input && passage.chapter ? reference : null} />\n      )}\n      {showMnemonics && (\n        <div>\n          <span onClick={() => setShowSlider((a) => !a)}>\n            {matches.length > 0 ? (\n              <>\n                {matches.length === maxWords\n                  ? matches.length + \"+\"\n                  : matches.length}{\" \"}\n                potential <PassageTokens passage={parse(mnemonic)} /> mnemonic\n                {matches.length > 1 && \"s\"}\n              </>\n            ) : (\n              <>\n                No words matching <PassageTokens passage={parse(mnemonic)} />{\" \"}\n                found.\n                <p className=\"hint\">\n                  Maybe it's an acronym? Good mental hooks take creativity!\n                </p>\n              </>\n            )}\n          </span>\n          {showSlider && (\n            <div>\n              Word esotericism:{\" \"}\n              <input\n                type=\"range\"\n                value={oddity}\n                min={0}\n                max={7}\n                onChange={(e) => setOddity(Number(e.target.value))}\n              />\n            </div>\n          )}\n          {matches.map((word, index) => (\n            <p key={index + word} style={{ margin: \"5px\" }}>\n              <small onClick={() => (window.location.search = \"?v=\" + word)}>\n                {word}\n              </small>\n            </p>\n          ))}\n        </div>\n      )}\n    </div>\n  );\n}\nconst maxWords = 1000;\nconst defaultInput = new URLSearchParams(window.location.search).get(\"v\") || \"\";\nexport default App;\n","import { randomWord, wordExists } from \"../data/words\";\nimport { Passage } from \"../passage/passage\";\n\nexport function randomWordPassage(oddity: number) {\n  while (true) {\n    const word = randomWord(oddity);\n    const passage = new Passage(word);\n    if (!passage.error) return passage;\n  }\n}\nexport function randomPassageReference(oddity: number): string {\n  let count = 0;\n  while (true) {\n    count++;\n    const passage = Passage.random;\n    const word = wordExists({ startsWith: passage.mnemonic, oddity });\n    if (word || count >= 70) {\n      console.log(count);\n      return passage.reference;\n    }\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}